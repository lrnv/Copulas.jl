Bestiary = [
    AMHCopula(2,-1.0),
    AMHCopula(2,-0.6),
    AMHCopula(2,0.7),
    AMHCopula(2,0.9),
    AMHCopula(3,-0.003),
    AMHCopula(3,0.6),
    AMHCopula(3,0.2),
    AMHCopula(4,-0.01),
    ArchimaxCopula(2, Copulas.BB1Generator(1.3, 1.4), Copulas.AsymGalambosTail(0.35, 0.65, 0.3)),
    ArchimaxCopula(2, Copulas.BB1Generator(1.3, 1.4), Copulas.GalambosTail(0.7)),
    ArchimaxCopula(2, Copulas.BB1Generator(1.3, 1.4), Copulas.GalambosTail(2.5)),
    ArchimaxCopula(2, Copulas.BB1Generator(1.3, 1.4), Copulas.HuslerReissTail(0.6)),
    ArchimaxCopula(2, Copulas.BB1Generator(1.3, 1.4), Copulas.HuslerReissTail(1.8)),
    ArchimaxCopula(2, Copulas.BB1Generator(1.3, 1.4), Copulas.LogTail(1.5)),
    ArchimaxCopula(2, Copulas.BB1Generator(1.3, 1.4), Copulas.LogTail(2.0)),
    ArchimaxCopula(2, Copulas.BB1Generator(2.0, 2.0), Copulas.AsymGalambosTail(0.35, 0.65, 0.3)),
    ArchimaxCopula(2, Copulas.BB1Generator(2.0, 2.0), Copulas.GalambosTail(0.7)),
    ArchimaxCopula(2, Copulas.BB1Generator(2.0, 2.0), Copulas.GalambosTail(2.5)),
    ArchimaxCopula(2, Copulas.BB1Generator(2.0, 2.0), Copulas.HuslerReissTail(0.6)),
    ArchimaxCopula(2, Copulas.BB1Generator(2.0, 2.0), Copulas.HuslerReissTail(1.8)),
    ArchimaxCopula(2, Copulas.BB1Generator(2.0, 2.0), Copulas.LogTail(1.5)),
    ArchimaxCopula(2, Copulas.BB1Generator(2.0, 2.0), Copulas.LogTail(2.0)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(1.5),  Copulas.AsymGalambosTail(0.35, 0.65, 0.3)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(1.5),  Copulas.GalambosTail(0.7)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(1.5),  Copulas.GalambosTail(2.5)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(1.5),  Copulas.HuslerReissTail(0.6)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(1.5),  Copulas.HuslerReissTail(1.8)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(1.5),  Copulas.LogTail(1.5)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(1.5),  Copulas.LogTail(2.0)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(3.0),  Copulas.AsymGalambosTail(0.35, 0.65, 0.3)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(3.0),  Copulas.GalambosTail(0.7)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(3.0),  Copulas.GalambosTail(2.5)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(3.0),  Copulas.HuslerReissTail(0.6)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(3.0),  Copulas.HuslerReissTail(1.8)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(3.0),  Copulas.LogTail(1.5)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(3.0),  Copulas.LogTail(2.0)),
    ArchimaxCopula(2, Copulas.FrankGenerator(0.8),    Copulas.AsymGalambosTail(0.35, 0.65, 0.3)),
    ArchimaxCopula(2, Copulas.FrankGenerator(0.8),    Copulas.GalambosTail(0.7)),
    ArchimaxCopula(2, Copulas.FrankGenerator(0.8),    Copulas.GalambosTail(2.5)),
    ArchimaxCopula(2, Copulas.FrankGenerator(0.8),    Copulas.HuslerReissTail(0.6)),
    ArchimaxCopula(2, Copulas.FrankGenerator(0.8),    Copulas.HuslerReissTail(1.8)),
    ArchimaxCopula(2, Copulas.FrankGenerator(0.8),    Copulas.LogTail(1.5)),
    ArchimaxCopula(2, Copulas.FrankGenerator(0.8),    Copulas.LogTail(2.0)),
    ArchimaxCopula(2, Copulas.FrankGenerator(6.0),    Copulas.AsymGalambosTail(0.35, 0.65, 0.3)),
    ArchimaxCopula(2, Copulas.FrankGenerator(6.0),    Copulas.GalambosTail(0.7)),
    ArchimaxCopula(2, Copulas.FrankGenerator(6.0),    Copulas.GalambosTail(2.5)),
    ArchimaxCopula(2, Copulas.FrankGenerator(6.0),    Copulas.HuslerReissTail(0.6)),
    ArchimaxCopula(2, Copulas.FrankGenerator(6.0),    Copulas.HuslerReissTail(1.8)),
    ArchimaxCopula(2, Copulas.FrankGenerator(6.0),    Copulas.LogTail(1.5)),
    ArchimaxCopula(2, Copulas.FrankGenerator(6.0),    Copulas.LogTail(2.0)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(2.0),   Copulas.AsymGalambosTail(0.35, 0.65, 0.3)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(2.0),   Copulas.GalambosTail(0.7)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(2.0),   Copulas.GalambosTail(2.5)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(2.0),   Copulas.HuslerReissTail(0.6)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(2.0),   Copulas.HuslerReissTail(1.8)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(2.0),   Copulas.LogTail(1.5)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(2.0),   Copulas.LogTail(2.0)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(4.0),   Copulas.AsymGalambosTail(0.35, 0.65, 0.3)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(4.0),   Copulas.GalambosTail(0.7)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(4.0),   Copulas.GalambosTail(2.5)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(4.0),   Copulas.HuslerReissTail(0.6)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(4.0),   Copulas.HuslerReissTail(1.8)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(4.0),   Copulas.LogTail(1.5)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(4.0),   Copulas.LogTail(2.0)),
    ArchimaxCopula(2, Copulas.JoeGenerator(1.2),      Copulas.AsymGalambosTail(0.35, 0.65, 0.3)),
    ArchimaxCopula(2, Copulas.JoeGenerator(1.2),      Copulas.GalambosTail(0.7)),
    ArchimaxCopula(2, Copulas.JoeGenerator(1.2),      Copulas.GalambosTail(2.5)),
    ArchimaxCopula(2, Copulas.JoeGenerator(1.2),      Copulas.HuslerReissTail(0.6)),
    ArchimaxCopula(2, Copulas.JoeGenerator(1.2),      Copulas.HuslerReissTail(1.8)),
    ArchimaxCopula(2, Copulas.JoeGenerator(1.2),      Copulas.LogTail(1.5)),
    ArchimaxCopula(2, Copulas.JoeGenerator(1.2),      Copulas.LogTail(2.0)),
    ArchimaxCopula(2, Copulas.JoeGenerator(2.5),      Copulas.AsymGalambosTail(0.35, 0.65, 0.3)),
    ArchimaxCopula(2, Copulas.JoeGenerator(2.5),      Copulas.GalambosTail(0.7)),
    ArchimaxCopula(2, Copulas.JoeGenerator(2.5),      Copulas.GalambosTail(2.5)),
    ArchimaxCopula(2, Copulas.JoeGenerator(2.5),      Copulas.HuslerReissTail(0.6)),
    ArchimaxCopula(2, Copulas.JoeGenerator(2.5),      Copulas.HuslerReissTail(1.8)),
    ArchimaxCopula(2, Copulas.JoeGenerator(2.5),      Copulas.LogTail(1.5)),
    ArchimaxCopula(2, Copulas.JoeGenerator(2.5),      Copulas.LogTail(2.0)),
    ArchimedeanCopula(10,ùí≤(Dirac(1),10)),
    ArchimedeanCopula(10,ùí≤(MixtureModel([Dirac(1), Dirac(2)]),11)),
    ArchimedeanCopula(2,ùí≤(LogNormal(),2)),
    ArchimedeanCopula(2,ùí≤(Pareto(1),5)),
    AsymGalambosCopula(2, 0.1, 0.2, 0.6),
    AsymGalambosCopula(2, 0.6129496106778634, 0.820474440393214, 0.22304578643880224),
    AsymGalambosCopula(2, 10+5*0.3, 1.0, 1.0),
    AsymGalambosCopula(2, 10+5*0.7, 0.2, 0.9),
    AsymGalambosCopula(2, 11.647356700032505, 0.6195348270893413, 0.4197760589260566),
    AsymGalambosCopula(2, 5.0, 0.8, 0.3),
    AsymGalambosCopula(2, 5+4*0.4, 1.0, 1.0),
    AsymGalambosCopula(2, 5+4*0.1, 0.2, 0.6),
    AsymGalambosCopula(2, 8.810168494949659, 0.5987759444612732, 0.5391280234619427),
    AsymGalambosCopula(2, 0.9, 1.0, 1.0),
    AsymGalambosCopula(2, 0.3, 0.8, 0.1),
    AsymLogCopula(2, 1.0, 0.0, 0.0),
    AsymLogCopula(2, 1.0, 1.0, 1.0),
    AsymLogCopula(2, 1.0, 0.1, 0.6),
    AsymLogCopula(2, 1.2, 0.3,0.6),
    AsymLogCopula(2, 1.5, 0.5, 0.2),
    AsymLogCopula(2, 1+4*0.9, 0.0, 0.0),
    AsymLogCopula(2, 1+4*0.01, 1.0, 1.0),
    AsymLogCopula(2, 1+4*0.2, 0.3, 0.4),
    AsymLogCopula(2, 10+5*0.5, 0.0, 0.0),
    AsymLogCopula(2, 10+5*0.6, 1.0, 1.0),
    AsymLogCopula(2, 10+5*0.7, 0.8, 0.2),
    AsymMixedCopula(2, 0.1, 0.2),
    AsymMixedCopula(2, 0.12, 0.13),
    BB1Copula(2, 0.35, 1.0),
    BB1Copula(2, 1.2, 1.5),
    BB1Copula(2, 2.5, 1.5),
    BB2Copula(2, 1.2, 0.5),
    BB2Copula(2, 1.5, 1.8),
    BB2Copula(2, 2.0, 1.5),
    BB3Copula(2, 2.0, 1.5),
    BB3Copula(2, 2.5, 0.5),
    BB3Copula(2, 3.0, 1.0),
    BB4Copula(2, 0.50, 1.60),
    BB4Copula(2, 2.50, 0.40),
    BB4Copula(2, 3.0, 2.1),
    BB5Copula(2, 1.50, 1.60),
    BB5Copula(2, 2.50, 0.40),
    BB5Copula(2, 5.0, 0.5),
    BB6Copula(2, 1.2, 1.6),
    BB6Copula(2, 1.5, 1.4),
    BB6Copula(2, 2.0, 1.5),
    BB7Copula(2, 1.2, 1.6),
    BB7Copula(2, 1.5, 0.4),
    BB7Copula(2, 2.0, 1.5),
    BB8Copula(2, 1.2, 0.4),
    BB8Copula(2, 1.5, 0.6),
    BB8Copula(2, 2.5, 0.8),
    BB9Copula(2, 1.5, 2.4),
    BB9Copula(2, 2.0, 1.5),
    BB9Copula(2, 2.8, 2.6),
    BB10Copula(2, 1.5, 0.7),
    BB10Copula(2, 3.0, 0.8),
    BB10Copula(2, 4.5, 0.6),
    BC2Copula(2, 0.5, 0.3),
    BC2Copula(2, 0.5, 0.5),
    BC2Copula(2, 0.5516353577049822, 0.33689370624999193),
    BC2Copula(2, 0.7,0.3),
    BC2Copula(2, 1.0, 0.0),
    BC2Copula(2, 1/2,1/2),
    BC2Copula(2, 0.6, 0.8),
    BernsteinCopula(ArchimaxCopula(2, Copulas.FrankGenerator(0.8), Copulas.HuslerReissTail(0.6)); m=5),
    BernsteinCopula(ClaytonCopula(3, 3.3); m=5),
    BernsteinCopula(GalambosCopula(2, 2.5); m=5),
    BernsteinCopula(GaussianCopula(2, 0.3); m=5),
    BernsteinCopula(IndependentCopula(4); m=5),
    BernsteinCopula(IndependentCopula(4); m=5),
    ClaytonCopula(2, -0.7),
    ClaytonCopula(2, 0.9),
    ClaytonCopula(2, 0.3),
    ClaytonCopula(2, 7),
    ClaytonCopula(3, 7.3),
    ClaytonCopula(3, -0.36),
    ClaytonCopula(4, 3.7),
    ClaytonCopula(4, -0.22),
    ClaytonCopula(4,7.),
    Copulas.SubsetCopula(RafteryCopula(3, 0.5), (2,1)),
    CuadrasAugeCopula(2, 0.0),
    CuadrasAugeCopula(2, 0.1),
    CuadrasAugeCopula(2, 0.3437537135972244),
    CuadrasAugeCopula(2, 0.7103550345192344),
    CuadrasAugeCopula(2, 0.8),
    CuadrasAugeCopula(2, 1.0),
    CuadrasAugeCopula(2, 0.2),
    FGMCopula(2, 0.0),
    FGMCopula(2, 0.4),
    FGMCopula(2,1),
    FGMCopula(3, [0.3,0.3,0.3,0.3]),
    FGMCopula(3,[0.1,0.2,0.3,0.4]),
    FrankCopula(2,-5),
    FrankCopula(2,0.5),
    FrankCopula(2,1-log(0.9)),
    FrankCopula(2,1.0),
    FrankCopula(3,1-log(0.1)),
    FrankCopula(3,1.0),
    FrankCopula(3,12),
    FrankCopula(4,1-log(0.3)),
    FrankCopula(4,1.0),
    FrankCopula(4,150),
    FrankCopula(4,30),
    FrankCopula(4,37),
    GalambosCopula(2, 0.3),
    GalambosCopula(2, 1+4*0.5),
    GalambosCopula(2, 120),
    GalambosCopula(2, 20),
    GalambosCopula(2, 210),
    GalambosCopula(2, 4.3),
    GalambosCopula(2, 8),
    GalambosCopula(2, 80),
    GalambosCopula(2, 0.7),
    GaussianCopula([1 0.5; 0.5 1]),
    GaussianCopula([1 0.7; 0.7 1]),
    GumbelBarnettCopula(2,1.0),
    GumbelBarnettCopula(2,0.7),
    GumbelBarnettCopula(3,0.1),
    GumbelBarnettCopula(3,0.35),
    GumbelBarnettCopula(3,0.2*0.38),
    GumbelBarnettCopula(4,0.2),
    GumbelCopula(2, 1.2),
    GumbelCopula(2,1-log(0.9)),
    GumbelCopula(2,8),
    GumbelCopula(3,1-log(0.2)),
    GumbelCopula(4,1-log(0.3)),
    GumbelCopula(4,100),
    GumbelCopula(4,20),
    GumbelCopula(4,7),
    HuslerReissCopula(2, 0.1),
    HuslerReissCopula(2, 0.256693308150987),
    HuslerReissCopula(2, 1.6287031392529938),
    HuslerReissCopula(2, 3.5),
    HuslerReissCopula(2, 5.319851350643586),
    IndependentCopula(2),
    IndependentCopula(3),
    InvGaussianCopula(2,-log(0.9)),
    InvGaussianCopula(2,1.0),
    InvGaussianCopula(2,0.2),
    InvGaussianCopula(3,-log(0.6)),
    InvGaussianCopula(3,0.4),
    InvGaussianCopula(4,-log(0.1)),
    InvGaussianCopula(4,0.05),
    InvGaussianCopula(4,1.0),
    JoeCopula(2,1-log(0.5)),
    JoeCopula(2,3),
    JoeCopula(2,Inf),
    JoeCopula(3,1-log(0.3)),
    JoeCopula(3,7),
    JoeCopula(4,1-log(0.1)),
    LogCopula(2, 1.5),
    LogCopula(2, 1+9*0.4),
    LogCopula(2, 5.5),
    MCopula(2),
    MCopula(4),
    MixedCopula(2, 0.0),
    MixedCopula(2, 0.2),
    MixedCopula(2, 0.5),
    MixedCopula(2, 1.0),
    MOCopula(2, 0.1,0.2,0.3),
    MOCopula(2, 0.5, 0.5, 0.5),
    MOCopula(2, 0.5960710257852946, 0.3313524247810329, 0.09653466861970061),
    MOCopula(2, 1.0, 1.0, 1.0),
    MOCopula(2, 0.1, 0.5, 0.9),
    PlackettCopula(0.5),
    PlackettCopula(0.8),
    PlackettCopula(2.0),
    RafteryCopula(2, 0.2),
    RafteryCopula(3, 0.5),
    SurvivalCopula(ClaytonCopula(2,-0.7),(1,2)),
    SurvivalCopula(RafteryCopula(2, 0.2), (2,1)),
    TCopula(2, [1 0.7; 0.7 1]),
    TCopula(20,[1 -0.5; -0.5 1]),
    TCopula(4, [1 0.5; 0.5 1]),
    tEVCopula(2, 10.0, 1.0),
    tEVCopula(2, 2.0, 0.5),
    tEVCopula(2, 3.0, 0.0),
    tEVCopula(2, 4.0, 0.5),
    tEVCopula(2, 4+6*0.5, -0.9+1.9*0.3),
    tEVCopula(2, 5.0, -0.5),
    tEVCopula(2, 5.466564460573727, -0.6566645244416698),
    WCopula(2),
    ]

# These few ones are forced to be random, but we control their rng like that to have reproducibility: 
Random.seed!(rng, 123)
append!(Bestiary, [
    ArchimedeanCopula(2, EmpiricalGenerator(randn(rng, 4, 150))),
    ArchimedeanCopula(3, EmpiricalGenerator(randn(rng, 3, 200))),
    BernsteinCopula(randn(rng, 2,100), pseudo_values=false),
    BetaCopula(randn(rng, 2,50)),
    BetaCopula(randn(rng, 3,50)),
    CheckerboardCopula(randn(rng, 2,50); pseudo_values=false),
    CheckerboardCopula(randn(rng, 3,50); pseudo_values=false),
    CheckerboardCopula(randn(rng, 4,50); pseudo_values=false),
    EmpiricalCopula(randn(2,50),pseudo_values=false),
    EmpiricalCopula(randn(2,50),pseudo_values=false),
    EmpiricalEVCopula(randn(rng, 2,50); method=:cfg, pseudo_values=false),
    EmpiricalEVCopula(randn(rng, 2,50); method=:ols, pseudo_values=false),
    EmpiricalEVCopula(randn(rng, 2,50); method=:pickands, pseudo_values=false),
])

macro testif(cond, args...)
    # --- Minimal, readable helper to conditionally run/skip whole testsets ---
    # Usage:
    #   @testif condition "Name" begin ... end
    #   @testif condition verbose=true "Name" begin ... end
    nargs = length(args)
    nargs >= 2 || error("Usage: @testif condition [options...] \"Name\" begin ... end")
    name  = args[end-1]
    block = args[end]
    opts  = nargs > 2 ? args[1:end-2] : ()
    return :(if $(esc(cond))
        Test.@testset $(opts...) $(name) begin
            $(esc(block))
        end
    else
        Test.@testset $(opts...) $(name) begin
            Test.@test_skip "skipped by @testif"
        end
    end)
end
can_pdf(C::CT) where CT = 
    applicable(Distributions._logpdf, C, ones(length(C),2)./2) &&
    !(CT<:EmpiricalCopula) &&
    !((CT<:ArchimedeanCopula) && length(C)==Copulas.max_monotony(C.G))

check_rosenblatt(C::CT) where CT = 
    !((CT<:ArchimedeanCopula) && length(C)==Copulas.max_monotony(C.G)) &&
    !((CT<:FrankCopula) && (C.G.Œ∏ >= 100)) &&
    !((CT<:GumbelCopula) && (C.G.Œ∏ >= 20)) &&
    !(CT<:MCopula{4}) &&
    !(CT<:EmpiricalCopula) &&
    !(CT<:BC2Copula)

check_corkendall(C::CT) where CT = 
    !((CT<:FrankCopula) && (C.G.Œ∏ >= 100)) &&
    !((CT<:GumbelCopula) && (C.G.Œ∏ >= 100)) &&
    !(CT<:Union{MCopula, WCopula}) &&
    !(CT<:EmpiricalCopula) &&
    !(CT<:BC2Copula) &&
    !(CT<:CuadrasAugeCopula) &&
    !(CT<:MOCopula) &&
    !(CT<:Copulas.ExtremeValueCopula{2, <:Copulas.EmpiricalEVTail})

is_archimedean_with_generator(C::CT) where CT =
    (CT<:ArchimedeanCopula) && !(typeof(C.G)<:Copulas.WilliamsonGenerator)

can_integrate_pdf(C::CT) where CT =  
    # This list might be longer than necessary, it should be trimmed.
    can_pdf(C) &&
    !(C isa ArchimedeanCopula && (C.G isa Copulas.WilliamsonGenerator) && (Copulas.max_monotony(C.G) > length(C))) &&
    !((CT<:FrankCopula) && (C.G.Œ∏ >= 100)) &&
    !((CT<:GumbelCopula) && (C.G.Œ∏ >= 100)) &&
    !((CT<:FGMCopula) && (length(C)==3)) &&
    !(CT<:MCopula) && 
    !(CT<:WCopula) && 
    !(CT<:MOCopula) && 
    !(CT<:CuadrasAugeCopula) && 
    !(CT<:RafteryCopula) && 
    !(CT<:EmpiricalCopula) && 
    !(CT<:BC2Copula) &&
    !(CT<:Copulas.ExtremeValueCopula{2, <:Copulas.EmpiricalEVTail}) &&
    !(CT<:CheckerboardCopula)

can_ad(C::CT) where CT = 
    # This list might be longer than necessary, it should be trimmed.
    can_pdf(C) &&
    !(C isa ArchimedeanCopula && (C.G isa Copulas.WilliamsonGenerator) && (Copulas.max_monotony(C.G) > length(C))) && # discontinuous. 
    !((CT<:FrankCopula) && (C.G.Œ∏ >= 100)) && # too extreme
    !((CT<:GumbelCopula) && ((C.G.Œ∏ >= 100)) && length(C) > 2) && # too extreme
    !(CT<:MCopula) && # not abs cont
    !(CT<:WCopula) && # not abs cont
    !(CT<:tEVCopula) && # requires derivatives of beta_inc_inv that forwardiff doesnt have. 
    !(CT<:TCopula) && # same
    !(CT<:CuadrasAugeCopula) && # discontinuous
    !(CT<:MOCopula) # discontinuous
    # !(CT<:BC2Copula) && # is discontinuous
    # !(CT<:AsymGalambosCopula) && 
    # !(CT<:GalambosCopula) && 
    # !(CT<:AsymLogCopula) && 
    # !(CT<:AsymMixedCopula) && 
    # !(CT<:GalambosCopula) && 
    # !(CT<:HuslerReissCopula) && 
    # !(CT<:MixedCopula) && 
    # !(CT<:LogCopula)

# --- Named predicate helpers for readability in @testif conditions ---
is_bivariate(C::CT)                      where CT = (length(C) == 2)
has_subsetdims(C::CT)                    where CT = (length(C) >= 3)
can_check_pdf_positivity(C::CT)          where CT = can_pdf(C) && !((CT<:GumbelCopula) && (C.G.Œ∏ >= 19))
dep_coherency_enabled(C::CT)         where CT = !(CT<:Union{MOCopula, Copulas.ExtremeValueCopula{2, <:Copulas.EmpiricalEVTail}})
can_check_biv_conditioning_ad(C::CT)     where CT = is_bivariate(C) && can_ad(C)
can_check_highdim_conditioning_ad(C::CT) where CT = (length(C) > 2) && can_ad(C)
has_uniform_margins(C::CT)               where CT = !(CT<:EmpiricalCopula)
is_archimedean(C::CT)                    where CT = (CT <: ArchimedeanCopula)
is_extremevalue(C::CT)                   where CT = (CT <: Copulas.ExtremeValueCopula)
is_archimax(C::CT)                       where CT = (CT <: Copulas.ArchimaxCopula)

can_be_fitted(C::CT, d) where CT = length(Copulas._available_fitting_methods(CT, d)) > 0
has_parameters(C::CT) where CT = !(CT <: Union{IndependentCopula, MCopula, WCopula})
has_unbounded_params(C::CT, d) where CT = has_parameters(C) &&  :mle ‚àà Copulas._available_fitting_methods(CT, d) && (length(Distributions.params(C)) > 0) && !(CT<:EmpiricalEVCopula) && !(d>2 && CT<:FGMCopula)
unbounding_is_a_bijection(C::Copulas.Copula{d}) where d = !(typeof(C)<:FGMCopula && d>2)

# A few technical helpers. 
_archimax_cdf_mockup(C::Copulas.ArchimaxCopula, u1::Real, u2::Real) = begin
    G, E = C.gen, C.tail
    (u1‚â§0 || u2‚â§0)  && return 0.0
    (u1‚â•1 && u2‚â•1)  && return 1.0
    x = Copulas.œï‚Åª¬π(G, u1); y = Copulas.œï‚Åª¬π(G, u2)
    S = x + y
    S == 0 && return 1.0
    t = y / S
    Copulas.œï(G, S * Copulas.A(E, t))
end
_archimax_pdf_hess(C, u1, u2) = begin
    f(z) = cdf(C, z)                      
    H = ForwardDiff.hessian(f, [u1, u2])  # ‚àÇ¬≤/‚àÇu1‚àÇu2
    max(H[1,2], 0.0)                      # numerical clip 
end
function _archimax_mc_rectangles_cdf(C; N::Int=2_000, seed::Integer=123,
                        rects::Tuple{Vararg{Tuple{<:Real,<:Real}}}=((0.5,0.5),(0.3,0.7),(0.8,0.2)))
    rng = StableRNG(seed)
    U = rand(rng, C, N)
    results = Vector{NamedTuple}(undef, length(rects))
    @inbounds for (k,(a,b)) in pairs(rects)
        p_th = cdf(C, [a,b])
        cnt = 0
        for i in 1:N
            (U[1,i] ‚â§ a && U[2,i] ‚â§ b) && (cnt += 1)
        end
        p_hat = cnt / N
        se = sqrt(p_th*(1-p_th)/N)
        results[k] = (rect=(a,b), p_hat=p_hat, p_th=p_th, se=se)
    end
    return results
end
function _integrate_pdf_rect(rng, C::Copulas.Copula{d}, a, b, N) where d
    ba = b .- a
    logvol = log(prod(ba))
    logS  = -Inf
    logS2 = -Inf
    u = zeros(d)
    x = similar(a)
    @inbounds for _ in 1:N
        rand!(rng, u)
        x .=  a .+ ba .* u
        lp = logpdf(C, x)
        if isfinite(lp)
            log_fx = lp + logvol
            logS   = LogExpFunctions.logaddexp(logS,  log_fx)
            logS2  = LogExpFunctions.logaddexp(logS2, 2 * log_fx)
        end
    end
    Œº  = exp(logS  - log(N))
    m2 = exp(logS2 - log(N))
    r  = max(m2 - Œº^2, 0.0) / N
    return Œº, r, :mc_pdf
end


# simple mockup for partial derivatives. 
function _cond_cdf(C::Copulas.Copula{d}, x, ujs) where d
    u,v =  x
    if d==3
        return ForwardDiff.derivative(w -> cdf(C, [u,v,w]), ujs[1])
    elseif d==4
        return ForwardDiff.derivative(t -> ForwardDiff.derivative(w -> cdf(C, [u,v,w,t]), ujs[1]), ujs[2]) / ForwardDiff.derivative(t -> ForwardDiff.derivative(w -> cdf(C, [1,1,w,t]), ujs[1]), ujs[2])
    end
end


# You can filter the bestiary here if you want: 
Bestiary = filter(GenericTestFilter, Bestiary)

# Launch the main computation: 
@testset for C in unique(Bestiary) 

    @info "Testing $C..."
    Random.seed!(rng,123)
    CT = typeof(C)
    d = length(C)
    
    Z = SklarDist(C, Tuple(Normal() for i in 1:d))
    spl1 = rand(rng, C)
    spl10 = rand(rng, C, 10)
    spl1000 = rand(rng, C, 1000)
    splZ10 = rand(rng, Z, 10)

    @testset "Basics" begin 
        @testset "Shape and support" begin 
            @test length(spl1)==d
            @test size(spl10) == (d,10)
            @test all(0 .<= spl10 .<= 1)
            @test all(0 .<= spl1000 .<= 1)
        end

        @testset "CDF boundary and measure" begin 
            @test iszero(cdf(C,zeros(d)))
            @test isone(cdf(C,ones(d)))
            @test 0 <= cdf(C,rand(rng,d)) <= 1
            @test cdf(Z,zeros(d)) >= 0
            @test Copulas.measure(C, zeros(d),    ones(d)) ‚âà 1
            @test Copulas.measure(C, ones(d)*0.2, ones(d)*0.4) >= 0
        end

        @testif has_subsetdims(C) "Subsetdims" begin
            sC = Copulas.subsetdims(C,(2,1))
            @test all(0 .<= cdf(sC, spl10[1:2,:]) .<= 1)
            @test sC == Copulas.subsetdims(Z,(2,1)).C
        end

        # Margins uniformity
        @testif has_uniform_margins(C) "Margins uniformity" begin
            for i in 1:d
                for val in [0,1,0.5,rand(rng,5)...]
                    u = ones(d)
                    u[i] = val
                    @test cdf(C,u) ‚âà val atol=1e-5
                end
                u = rand(rng,d)
                u[i] = 0
                @test iszero(cdf(C,u))

                # This pvalue test fails sometimes.. which is normal since its random, but its anoying ^^
                # @test pvalue(ApproximateOneSampleKSTest(spl1000[i,:], Uniform())) > 0.005
            end
        end

        @testif can_check_pdf_positivity(C) "PDF positivity" begin
            r10 = pdf(C, spl10)
            @test pdf(C, zeros(d) .+ 1e-5) >= 0
            @test pdf(C, ones(d)/2)      >= 0
            @test pdf(C, ones(d) .- 1e-5) >= 0
            @test (all(r10 .>= 0) && all(isfinite.(r10)))
        end 


        # This test takes more than 5 hours to run 
        # This is clarly unacceptable, but moreover we dont know which copula takes the most time 
        # sadly ;)
        
        # @testif dep_coherency_enabled(C) "Dependence metrics coherency" begin
        #     # Empirical vs theoretical for available metrics, mirroring Kendall‚Äôs pattern
        #     metrics = (
        #         ("tau", Copulas.œÑ, StatsBase.corkendall, 0.10, -1, 1), 
        #         ("rho", Copulas.œÅ, StatsBase.corspearman, 0.10, -1 , 1), 
        #         ("beta", Copulas.Œ≤, Copulas.corblomqvist, 0.10, -1 , 1), 
        #         ("gamma", Copulas.Œ≥, Copulas.corgini, 0.15, -1 , 1), 
        #         ("iota", Copulas.Œπ, Copulas.corentropy, 0.15, -Inf , 0)
        #     )
        #     for (name, f, corf, tol, lb, ub) in metrics
        #         @testset "$name" begin
        #             thf = f(C)
        #             thcorf = corf(C)
        #             empf = f(spl1000)
                    
        #             @test isapprox(empf, thf; atol=tol)
        #             @test lb ‚â§ thf ‚â§ ub
        #             @test lb ‚â§ empf ‚â§ ub
        #             @test all(lb .‚â§ thcorf .‚â§ ub)

        #             if which(f, (CT,)) !=  which(f, (Copulas.Copula{d},))
        #                 thf_gen  = @invoke f(C::Copulas.Copula{d})
        #                 # Allow tiny numerical discrepancies
        #                 @test isapprox(thf, thf_gen; atol= (C isa GaussianCopula ? 0.1 : 0.001))
        #             end
        #             if d == 2
        #                 @test isapprox(thf, thcorf[1,2]; atol=0.1)
        #             else
        #                 @test all(lb .<= thcorf .<= ub)
        #             end
        #             if check_rosenblatt(C)
        #                 U = rosenblatt(C, spl1000)
        #                 empfu = f(U)
        #                 empcorfu = corf(U')
        #                 @test isapprox(empfu, 0.0; atol=tol+0.05)
        #                 for i in 1:(d - 1)
        #                     for j in (i + 1):d
        #                         @test empcorfu[i,j] ‚âà 0.0 atol = 0.15
        #                     end
        #                 end
        #             end
        #         end
        #     end

        @testif dep_coherency_enabled(C) "Corkendall coeherency" begin
            K = corkendall(spl1000')
            Kth = corkendall(C)
            @test all(-1 .<= Kth .<= 1)
            @test all(isapprox.(Kth, K; atol=0.2))
        end
    end

    @testif can_integrate_pdf(C) "Testing pdf integration" begin
        # 1) ‚à´_{[0,1]^d} pdf = 1  (hcubature if d‚â§3; si no, MC)
        v, r, _ = _integrate_pdf_rect(rng, C, zeros(d), ones(d), 1_500)
        @test isapprox(v, 1; atol=max(5*sqrt(r), 1e-3))

        # 2) ‚à´_{[0,0.5]^d} pdf = C(0.5,‚Ä¶,0.5)
        b = ones(d)/2
        v2, r2, _ = _integrate_pdf_rect(rng, C, zeros(d), b, 1_500)
        @test isapprox(v2, cdf(C, b); atol=max(10*sqrt(r2), 1e-3))

        # 3) random rectangle, compare with measure (cdf based)
        a = rand(rng, d)
        b = a .+ rand(rng, d) .* (1 .- a)
        v3, r3, _ = _integrate_pdf_rect(rng, C, a, b, 1_500)
        @test (isapprox(v3, Copulas.measure(C, a, b); atol=max(20*sqrt(r3), 1e-3)) || max(v3, Copulas.measure(C, a, b)) < eps(Float64)) # wide tolerence, should pass. 
    end

    @testif check_rosenblatt(C) "rosenblatt ‚àò inverse_rosenblatt = Id" begin
        @test spl10 ‚âà inverse_rosenblatt(C, rosenblatt(C, spl10)) atol=1e-2
    end

    @testif check_corkendall(C) "corkendall ‚àò rosenblatt = I" begin
        U = rosenblatt(C, spl1000)
        for i in 1:(d - 1)
            for j in (i + 1):d
                @test corkendall(U[i, :], U[j, :]) ‚âà 0.0 atol = 0.15
            end
        end
    end

    @testset "Conditionning" begin
        # Conditioning tests (p = 1), validate against AD ratio and compare fast-paths to fallback
        # Always run basic sanity checks for bivariate conditionals; AD checks are gated below
        @testif is_bivariate(C) "Condition(2 | 1): Basics" begin
            us = (0.2, 0.5, 0.8)
            for j in 1:2
                i = 3 - j
                for v in (0.3, 0.7)
                    Dd = Copulas.condition(C, j, v)
                    vals = cdf.(Ref(Dd), us)
                    @test all(0.0 .<= vals .<= 1.0)
                    @test all(diff(collect(vals)) .>= -1e-10)
                    if !can_ad(C)
                        if CT <: Copulas.MCopula
                            @test all(vals .‚âà min.(collect(us) ./ v, 1))
                        elseif CT <: Copulas.WCopula
                            @test all(vals .‚âà max.(collect(us) .+ v .- 1, 0) ./ v)
                        end
                    end
                end
            end
        end

        # AD-based equivalence and fast-path comparisons (bivariate)
        @testif can_check_biv_conditioning_ad(C) "Condition(2 | 1): Check Distortion vs AD" begin
            us = (0.2, 0.5, 0.8)
            for j in 1:2
                i = 3 - j
                for v in (0.3, 0.7)
                    Dd = Copulas.condition(C, j, v)
                    vals = cdf.(Ref(Dd), us)

                    if j==2
                        refs = [ForwardDiff.derivative(t -> cdf(C, [ui, t]), v) for ui in us]
                    else
                        refs = [ForwardDiff.derivative(t -> cdf(C, [t, ui]), v) for ui in us]
                    end

                    for (v_, r) in zip(vals, refs)
                        @test isapprox(v_, r, atol=1e-3, rtol=1e-3)
                    end
                    # Compare fast path vs generic fallback only if a specialization exists
                    m_fast = which(Copulas.DistortionFromCop, (CT,                NTuple{1,Int}, NTuple{1,Float64}, Int))
                    m_gen  = which(Copulas.DistortionFromCop, (Copulas.Copula{2}, NTuple{1,Int}, NTuple{1,Float64}, Int))
                    if m_fast != m_gen
                        Dgen = @invoke Copulas.DistortionFromCop(C::Copulas.Copula{2}, (j,), (Float64(v),), i)
                        vals2 = cdf.(Ref(Dgen), us)
                        for (v2, r) in zip(vals2, refs)
                            @test isapprox(v2, r, atol=1e-3, rtol=1e-2)
                        end
                        for (v2, v_) in zip(vals2, vals)
                            @test isapprox(v2, v_, atol=1e-3, rtol=1e-3)
                        end
                    end
                end
            end
        end

        # High-dimensional AD-based checks
        @testif can_check_highdim_conditioning_ad(C) "Condition(d|d-1): Check Distortion vs AD" begin
            # Spot-check a single index pair (i,j) using the 2D projection via subsetdims
            j, i, v, us = 1, 2, 0.6, (0.2, 0.5, 0.8)

            # Distortion for Ui | Uj=v computed from full model
            D·µ¢ = condition(C, j, v).m[1]
            vals = cdf.(Ref(D·µ¢), us)
            @test all(0.0 .<= vals .<= 1.0)
            @test all(diff([vals...]) .>= -1e-10) # increasingness with tolerence.

            # Validate marginal distortion against AD on the 2D subset (i maps to 1, j maps to 2)
            Cproj = Copulas.subsetdims(C, (i, j))
            if can_ad(Cproj)
                refs = [ForwardDiff.derivative(x -> cdf(Cproj, [x,u]), v) for u in us]
                for (v_,r) in zip(vals, refs)
                    @test isapprox(v_, r, atol=1e-5, rtol=1e-5)
                end
            end
        end

        @testif (can_check_highdim_conditioning_ad(C) && d ‚àà(3,4)) "Condition (d|d-2): Check conditional copula vs AD" begin
            js = tuple(collect(3:d)...)
            ujs = tuple(collect(0.25 + 0.5*rand(rng) for _ in js)...)  # interior values
            CC = condition(C, js, ujs)

            # test grid on [0,1]^2
            pts = [(0.2,0.3), (0.5,0.5), (0.8,0.6)]
            for (v1,v2) in pts
                val_fast = cdf(CC, [v1, v2]) # our implementation
                val_ref = _cond_cdf(C, [v1,v2], ujs) # AD reference. 
                @test isapprox(val_fast, val_ref; atol=5e-5, rtol=5e-5)
            end
            # compare specialized ConditionalCopula vs generic fallback when specialization exists
            let m_fast = which(Copulas.ConditionalCopula, (CT,                NTuple{d-2, Int}, NTuple{d-2, Float64})),
                m_gen  = which(Copulas.ConditionalCopula, (Copulas.Copula{d}, NTuple{d-2, Int}, NTuple{d-2, Float64}))
                if m_fast != m_gen
                    CC_fast = Copulas.ConditionalCopula(C, js, ujs)
                    CC_gen = @invoke Copulas.ConditionalCopula(C::Copulas.Copula{d}, js, ujs)
                    for (v1,v2) in pts
                        @test cdf(CC_fast, [v1,v2]) ‚âà cdf(CC_gen, [v1,v2]) atol=1e-8 rtol=1e-8
                    end
                end
            end
        end
    end
    
    @testif is_archimedean_with_generator(C) "ArchimedeanCopula specific tests" begin 
        # Only test things if there are specilized versions of the functions. 
        spe_œï1 = which(Copulas.œï‚ÅΩ¬π‚Åæ, (typeof(C.G), Float64)) != which(Copulas.œï‚ÅΩ¬π‚Åæ, (Copulas.Generator, Float64))
        spe_œïk = which(Copulas.œï‚ÅΩ·µè‚Åæ, (typeof(C.G), Int, Float64)) != which(Copulas.œï‚ÅΩ·µè‚Åæ, (Copulas.Generator, Int, Float64))
        spe_œïinv = which(Copulas.œï‚Åª¬π, (typeof(C.G), Float64)) != which(Copulas.œï‚Åª¬π, (Copulas.Generator, Float64))
        spe_œïinv1 = which(Copulas.œï‚Åª¬π‚ÅΩ¬π‚Åæ, (typeof(C.G), Float64)) != which(Copulas.œï‚Åª¬π‚ÅΩ¬π‚Åæ, (Copulas.Generator, Float64))
        spe_œïkinv = which(Copulas.œï‚ÅΩ·µè‚Åæ‚Åª¬π, (typeof(C.G), Int, Float64)) != which(Copulas.œï‚ÅΩ·µè‚Åæ‚Åª¬π, (Copulas.Generator, Int, Float64))

        mm = Copulas.max_monotony(C.G)
        
        can_œÑinv = applicable(Copulas.œÑ, C.G) && applicable(Copulas.œÑ‚Åª¬π,typeof(C.G), 1.0)
        can_œÅinv = applicable(Copulas.œÅ, C.G) && applicable(Copulas.œÅ‚Åª¬π,typeof(C.G), 1.0)
        GT = Copulas.generatorof(CT)

        @testif spe_œïinv "Check œï ‚àò œï‚Åª¬π == Id over [0,1]" begin
            for x in 0:0.1:1
                @test Copulas.œï(C.G,Copulas.œï‚Åª¬π(C.G,x)) ‚âà x atol=1e-10
            end
        end

        @testif spe_œï1 "Check d(œï) == œï‚ÅΩ¬π‚Åæ" begin 
            @test ForwardDiff.derivative(x -> Copulas.œï(C.G, x), 0.1) ‚âà Copulas.œï‚ÅΩ¬π‚Åæ(C.G, 0.1)
        end

        @testif spe_œïk "Check d(œï) == œï‚ÅΩ·µè‚Åæ(k=1)" begin
            @test ForwardDiff.derivative(x -> Copulas.œï(C.G, x), 0.1) ‚âà Copulas.œï‚ÅΩ·µè‚Åæ(C.G, 1, 0.1)
        end

        @testif (spe_œï1 || spe_œïk) "Check œï‚ÅΩ¬π‚Åæ == œï‚ÅΩ·µè‚Åæ(k=1)" begin
            @test Copulas.œï‚ÅΩ¬π‚Åæ(C.G, 0.1) ‚âà Copulas.œï‚ÅΩ·µè‚Åæ(C.G, 1, 0.1)
        end
        @testif (spe_œï1 || spe_œïk) "Check d(œï‚ÅΩ¬π‚Åæ) == œï‚ÅΩ·µè‚Åæ(k=2)" begin
            @test ForwardDiff.derivative(x -> Copulas.œï‚ÅΩ¬π‚Åæ(C.G, x), 0.1) ‚âà Copulas.œï‚ÅΩ·µè‚Åæ(C.G, 2, 0.1)
        end

        @testif spe_œïinv1 "Check d(œï‚Åª¬π) == œï‚Åª¬π‚ÅΩ¬π‚Åæ" begin
            @test ForwardDiff.derivative(x -> Copulas.œï‚Åª¬π(C.G, x), 0.5) ‚âà Copulas.œï‚Åª¬π‚ÅΩ¬π‚Åæ(C.G, 0.5)
        end

        @testif spe_œïkinv "Check œï‚ÅΩ·µè‚Åæ‚Åª¬π ‚àò œï‚ÅΩ·µè‚Åæ == Id for k in 1:d-2" begin
            for k in 1:d-2
                @test Copulas.œï‚ÅΩ·µè‚Åæ‚Åª¬π(C.G,k, Copulas.œï‚ÅΩ·µè‚Åæ(C.G, k, 0.1)) ‚âà 0.1
            end
        end

        # For generators that are only d-monotonous, this does not need to be true. 
        @testif (spe_œïkinv && (mm > d)) "Check œï‚ÅΩ·µè‚Åæ‚Åª¬π ‚àò œï‚ÅΩ·µè‚Åæ == Id for k=d-1" begin 
            @test Copulas.œï‚ÅΩ·µè‚Åæ‚Åª¬π(C.G,d-1, Copulas.œï‚ÅΩ·µè‚Åæ(C.G, d-1, 0.1)) ‚âà 0.1
        end

        @testif can_œÑinv "Check œÑ ‚àò œÑ‚Åª¬π == Id" begin
            tau = Copulas.œÑ(C)
            @test Copulas.œÑ(GT(Copulas.œÑ‚Åª¬π(CT,tau))) ‚âà tau
        end
        
        @testif can_œÅinv "Check œÅ ‚àò œÅ‚Åª¬π == Id" begin
            rho = Copulas.œÅ(C)
            @test -1 <= rho <= 1
            @test Copulas.œÅ(GT(Copulas.œÅ‚Åª¬π(CT,rho))) ‚âà rho
        end

        if C.G isa Copulas.FrailtyGenerator
            F = frailty(C.G)
            spe_œï = which(Copulas.œï, (typeof(C.G), Float64)) != which(Copulas.œï, (Copulas.FrailtyGenerator, Float64))
            @testif (spe_œï && applicable(mgf, F, -1.0)) "Check frailty matches œï" begin
                for t in 0:0.1:2
                    @test œï(C.G, t) == mgf(F, -t)
                end
            end
        end

        @testset "Kendall-Radial coherency test" begin
            # On radial-level: 
            R1 = dropdims(sum(Copulas.œï‚Åª¬π.(C.G,spl1000),dims=1),dims=1)
            R2 = rand(rng,Copulas.ùí≤‚Çã‚ÇÅ(C.G, d),1000)
            @test pvalue(ApproximateTwoSampleKSTest(R1,R2)) > 0.005

            # On kendall-level: 
            U1 = Distributions.cdf(C, spl1000)
            U2 = Copulas.œï.(Ref(C.G), rand(rng,Copulas.ùí≤‚Çã‚ÇÅ(C.G, d),1000))
            @test pvalue(ApproximateTwoSampleKSTest(U1, U2)) > 0.005
        end
    end

    # Extreme value copula-specific tests (bivariate)
    @testif (is_extremevalue(C) && is_bivariate(C)) "ExtremeValueCopula specific tests" begin
            @testset "A function basics" begin
                @test Copulas.A(C.tail, 0.0) ‚âà 1
                @test Copulas.A(C.tail, 1.0) ‚âà 1
                t = rand(rng)
                A_value = Copulas.A(C.tail, t)
                @test 0.0 <= A_value <= 1.0
                @test isapprox(A_value, max(t, 1-t); atol=1e-6) || A_value >= max(t, 1-t)
                @test A_value <= 1.0
            end

            # Only run derivative and related tests if the methods are specialized for this type
            spe_dA =        which(Copulas.dA, (typeof(C.tail), Float64))        != which(Copulas.dA, (Copulas.Tail2, Float64))
            spe_d¬≤A =       which(Copulas.d¬≤A, (typeof(C.tail), Float64))       != which(Copulas.d¬≤A, (Copulas.Tail2, Float64))
            spe__A_dA_d¬≤A = which(Copulas._A_dA_d¬≤A, (typeof(C.tail), Float64)) != which(Copulas._A_dA_d¬≤A, (Copulas.Tail2, Float64))
            spe_‚Ñì =         which(Copulas.‚Ñì, (typeof(C.tail), Tuple{Float64, Float64})) != which(Copulas.‚Ñì, (Copulas.Tail2, Tuple{Float64, Float64}))

            @testif (spe_dA || spe_d¬≤A || spe__A_dA_d¬≤A) "Testing derivatives of A" begin
                # FD-based checks only when available
                @testif !(CT<:tEVCopula) "FD derivatives availability" begin
                    for t in (0.05, 0.5, 0.95)
                        @test isapprox(Copulas.dA(C.tail, t), ForwardDiff.derivative(x -> Copulas.A(C.tail, x), t); atol=1e-6)
                        @test isapprox(Copulas.d¬≤A(C.tail, t), ForwardDiff.derivative(x -> Copulas.dA(C.tail, x), t); atol=1e-6)
                    end
                end
                # Triplet consistency always
                for t in (0.05, 0.5, 0.95)
                    a, da, d2a = Copulas._A_dA_d¬≤A(C.tail, t)
                    @test isapprox(a, Copulas.A(C.tail, t); atol=1e-8)
                    @test isapprox(da, Copulas.dA(C.tail, t); atol=1e-8)
                    @test isapprox(d2a, Copulas.d¬≤A(C.tail, t); atol=1e-8)
                end
            end

            @testif (spe_dA || spe_d¬≤A || spe__A_dA_d¬≤A || spe_‚Ñì) "Testing ‚Ñì and cdf for Extreme Value Copula" begin 
                u, v = rand(rng), rand(rng)
                x, y = -log(u), -log(v)
                s = y / (x + y)
                expected_‚Ñì = Copulas.A(C.tail, s) * (x + y)
                @test isapprox(Copulas.‚Ñì(C.tail, (x, y)), expected_‚Ñì; atol=0.1)
                expected_cdf = exp(-expected_‚Ñì)
                @test isapprox(cdf(C, [u, v]), expected_cdf; atol=0.1)

                @testif !(CT<:tEVCopula) "pdf via FD matches analytic" begin
                    u, v = rand(rng), rand(rng)
                    num_pdf = ForwardDiff.derivative(u_ -> ForwardDiff.derivative(v_ -> cdf(C, [u_, v_]), v), u)
                    ana_pdf = pdf(C, [u, v])
                    @test isapprox(ana_pdf, num_pdf; atol=0.1)
                end
            end
    end

    # Archimax specific tests
    @testif is_archimax(C) "ArchimaxCopula specific tests" begin

            for (u1,u2) in ((0.2,0.3), (0.7,0.6), (0.9,0.4))
                @test isapprox(cdf(C, [u1,u2]), _archimax_cdf_mockup(C, u1, u2); rtol=1e-12, atol=1e-12)
            end

            for (u1,u2) in ((0.25,0.4), (0.6,0.6))
                lp = logpdf(C, [u1,u2])
                @test isfinite(lp)
                c_h = _archimax_pdf_hess(C, u1, u2)
                @test isapprox(exp(lp), c_h; rtol=1e-6, atol=1e-8)
            end

            for r in _archimax_mc_rectangles_cdf(C; N=1_500, seed=321)
                @test abs(r.p_hat - r.p_th) ‚â§ max(5*r.se, 2e-3)
            end
    end

    @testif can_be_fitted(C, d) "Fitting interface"  begin
        @testif has_unbounded_params(C, d) "Unbouding and rebounding params" begin
            # First on the _example copula. 
            Œ∏‚ÇÄ = Distributions.params(Copulas._example(CT, d))
            Œ∏‚ÇÅ = Copulas._rebound_params(CT, d, Copulas._unbound_params(CT, d, Œ∏‚ÇÄ))
            @testif unbounding_is_a_bijection(C) "bijective unbounding" begin 
                @test all(k->getfield(Œ∏‚ÇÄ,k) ‚âà getfield(Œ∏‚ÇÅ,k), keys(Œ∏‚ÇÄ))
            end
            @test Copulas._unbound_params(CT, d, Distributions.params(CT(d, Œ∏‚ÇÄ...))) == Copulas._unbound_params(CT, d, Œ∏‚ÇÄ)

            # Then on the copula we have at hand:
            Œ∏‚ÇÄ = Distributions.params(C)
            Œ∏‚ÇÅ = Copulas._rebound_params(CT, d, Copulas._unbound_params(CT, d, Œ∏‚ÇÄ))
            @testif unbounding_is_a_bijection(C) "bijective unbounding" begin 
                @test all(k->getfield(Œ∏‚ÇÄ,k) ‚âà getfield(Œ∏‚ÇÅ,k), keys(Œ∏‚ÇÄ))
            end
            @test Copulas._unbound_params(CT, d, Distributions.params(CT(d, Œ∏‚ÇÄ...))) == Copulas._unbound_params(CT, d, Œ∏‚ÇÄ)
        end

        methods = Copulas._available_fitting_methods(CT, d)
        for m in methods
            if (CT<:GumbelCopula && C.G.Œ∏ > 19 && m==:irho) || (CT<:FrankCopula && C.G.Œ∏ > 99 && m==:mle) || (CT<:RafteryCopula && d==3 && m==:itau)
                continue
            end 
            @testset "Fitting CT for $(m)" begin
                r1 = fit(CT, spl10, m)
                r2 = fit(CopulaModel, CT, spl10, m, quick_fit=true).result # no need to do the rest here. 
                newCT = typeof(r1)
                @test typeof(r2) == newCT
                if !(newCT<:ArchimedeanCopula{d, <:WilliamsonGenerator}) &&
                   !(newCT<:PlackettCopula) &&
                   has_parameters(r2) &&
                   has_unbounded_params(r2, d) &&
                   !(CT<:RafteryCopula && d==3 && m==:itau)

                    Œ±1 = Copulas._unbound_params(typeof(r1), d, Distributions.params(r1))
                    Œ±2 = Copulas._unbound_params(typeof(r2), d, Distributions.params(r2))
                    @test Œ±1 ‚âà Œ±2 atol= (CT<:GaussianCopula ? 1e-2 : 1e-5)
                end
            end
            r3 = fit(SklarDist{CT,  NTuple{d, Normal}}, splZ10)  # just to see if the function goes through.
        end
    end
end