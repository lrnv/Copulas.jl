Bestiary = [
    AMHCopula(2,-1.0),
    AMHCopula(2,-0.6),
    AMHCopula(2,0.7),
    AMHCopula(2,0.9),
    AMHCopula(3,-0.003),
    AMHCopula(3,0.6),
    AMHCopula(3,0.2),
    AMHCopula(4,-0.01),
    ArchimaxCopula(2, Copulas.BB1Generator(1.3, 1.4), Copulas.AsymGalambosTail(0.35, 0.65, 0.3)),
    ArchimaxCopula(2, Copulas.BB1Generator(1.3, 1.4), Copulas.GalambosTail(0.7)),
    ArchimaxCopula(2, Copulas.BB1Generator(1.3, 1.4), Copulas.GalambosTail(2.5)),
    ArchimaxCopula(2, Copulas.BB1Generator(1.3, 1.4), Copulas.HuslerReissTail(0.6)),
    ArchimaxCopula(2, Copulas.BB1Generator(1.3, 1.4), Copulas.HuslerReissTail(1.8)),
    ArchimaxCopula(2, Copulas.BB1Generator(1.3, 1.4), Copulas.LogTail(1.5)),
    ArchimaxCopula(2, Copulas.BB1Generator(1.3, 1.4), Copulas.LogTail(2.0)),
    ArchimaxCopula(2, Copulas.BB1Generator(2.0, 2.0), Copulas.AsymGalambosTail(0.35, 0.65, 0.3)),
    ArchimaxCopula(2, Copulas.BB1Generator(2.0, 2.0), Copulas.GalambosTail(0.7)),
    ArchimaxCopula(2, Copulas.BB1Generator(2.0, 2.0), Copulas.GalambosTail(2.5)),
    ArchimaxCopula(2, Copulas.BB1Generator(2.0, 2.0), Copulas.HuslerReissTail(0.6)),
    ArchimaxCopula(2, Copulas.BB1Generator(2.0, 2.0), Copulas.HuslerReissTail(1.8)),
    ArchimaxCopula(2, Copulas.BB1Generator(2.0, 2.0), Copulas.LogTail(1.5)),
    ArchimaxCopula(2, Copulas.BB1Generator(2.0, 2.0), Copulas.LogTail(2.0)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(1.5),  Copulas.AsymGalambosTail(0.35, 0.65, 0.3)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(1.5),  Copulas.GalambosTail(0.7)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(1.5),  Copulas.GalambosTail(2.5)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(1.5),  Copulas.HuslerReissTail(0.6)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(1.5),  Copulas.HuslerReissTail(1.8)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(1.5),  Copulas.LogTail(1.5)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(1.5),  Copulas.LogTail(2.0)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(3.0),  Copulas.AsymGalambosTail(0.35, 0.65, 0.3)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(3.0),  Copulas.GalambosTail(0.7)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(3.0),  Copulas.GalambosTail(2.5)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(3.0),  Copulas.HuslerReissTail(0.6)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(3.0),  Copulas.HuslerReissTail(1.8)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(3.0),  Copulas.LogTail(1.5)),
    ArchimaxCopula(2, Copulas.ClaytonGenerator(3.0),  Copulas.LogTail(2.0)),
    ArchimaxCopula(2, Copulas.FrankGenerator(0.8),    Copulas.AsymGalambosTail(0.35, 0.65, 0.3)),
    ArchimaxCopula(2, Copulas.FrankGenerator(0.8),    Copulas.GalambosTail(0.7)),
    ArchimaxCopula(2, Copulas.FrankGenerator(0.8),    Copulas.GalambosTail(2.5)),
    ArchimaxCopula(2, Copulas.FrankGenerator(0.8),    Copulas.HuslerReissTail(0.6)),
    ArchimaxCopula(2, Copulas.FrankGenerator(0.8),    Copulas.HuslerReissTail(1.8)),
    ArchimaxCopula(2, Copulas.FrankGenerator(0.8),    Copulas.LogTail(1.5)),
    ArchimaxCopula(2, Copulas.FrankGenerator(0.8),    Copulas.LogTail(2.0)),
    ArchimaxCopula(2, Copulas.FrankGenerator(6.0),    Copulas.AsymGalambosTail(0.35, 0.65, 0.3)),
    ArchimaxCopula(2, Copulas.FrankGenerator(6.0),    Copulas.GalambosTail(0.7)),
    ArchimaxCopula(2, Copulas.FrankGenerator(6.0),    Copulas.GalambosTail(2.5)),
    ArchimaxCopula(2, Copulas.FrankGenerator(6.0),    Copulas.HuslerReissTail(0.6)),
    ArchimaxCopula(2, Copulas.FrankGenerator(6.0),    Copulas.HuslerReissTail(1.8)),
    ArchimaxCopula(2, Copulas.FrankGenerator(6.0),    Copulas.LogTail(1.5)),
    ArchimaxCopula(2, Copulas.FrankGenerator(6.0),    Copulas.LogTail(2.0)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(2.0),   Copulas.AsymGalambosTail(0.35, 0.65, 0.3)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(2.0),   Copulas.GalambosTail(0.7)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(2.0),   Copulas.GalambosTail(2.5)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(2.0),   Copulas.HuslerReissTail(0.6)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(2.0),   Copulas.HuslerReissTail(1.8)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(2.0),   Copulas.LogTail(1.5)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(2.0),   Copulas.LogTail(2.0)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(4.0),   Copulas.AsymGalambosTail(0.35, 0.65, 0.3)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(4.0),   Copulas.GalambosTail(0.7)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(4.0),   Copulas.GalambosTail(2.5)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(4.0),   Copulas.HuslerReissTail(0.6)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(4.0),   Copulas.HuslerReissTail(1.8)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(4.0),   Copulas.LogTail(1.5)),
    ArchimaxCopula(2, Copulas.GumbelGenerator(4.0),   Copulas.LogTail(2.0)),
    ArchimaxCopula(2, Copulas.JoeGenerator(1.2),      Copulas.AsymGalambosTail(0.35, 0.65, 0.3)),
    ArchimaxCopula(2, Copulas.JoeGenerator(1.2),      Copulas.GalambosTail(0.7)),
    ArchimaxCopula(2, Copulas.JoeGenerator(1.2),      Copulas.GalambosTail(2.5)),
    ArchimaxCopula(2, Copulas.JoeGenerator(1.2),      Copulas.HuslerReissTail(0.6)),
    ArchimaxCopula(2, Copulas.JoeGenerator(1.2),      Copulas.HuslerReissTail(1.8)),
    ArchimaxCopula(2, Copulas.JoeGenerator(1.2),      Copulas.LogTail(1.5)),
    ArchimaxCopula(2, Copulas.JoeGenerator(1.2),      Copulas.LogTail(2.0)),
    ArchimaxCopula(2, Copulas.JoeGenerator(2.5),      Copulas.AsymGalambosTail(0.35, 0.65, 0.3)),
    ArchimaxCopula(2, Copulas.JoeGenerator(2.5),      Copulas.GalambosTail(0.7)),
    ArchimaxCopula(2, Copulas.JoeGenerator(2.5),      Copulas.GalambosTail(2.5)),
    ArchimaxCopula(2, Copulas.JoeGenerator(2.5),      Copulas.HuslerReissTail(0.6)),
    ArchimaxCopula(2, Copulas.JoeGenerator(2.5),      Copulas.HuslerReissTail(1.8)),
    ArchimaxCopula(2, Copulas.JoeGenerator(2.5),      Copulas.LogTail(1.5)),
    ArchimaxCopula(2, Copulas.JoeGenerator(2.5),      Copulas.LogTail(2.0)),
    ArchimedeanCopula(10,ğ’²(Dirac(1),10)),
    ArchimedeanCopula(10,ğ’²(MixtureModel([Dirac(1), Dirac(2)]),11)),
    ArchimedeanCopula(2,ğ’²(LogNormal(),2)),
    ArchimedeanCopula(2,ğ’²(Pareto(1),5)),
    AsymGalambosCopula(2, 0.1, 0.2, 0.6),
    AsymGalambosCopula(2, 0.6129496106778634, 0.820474440393214, 0.22304578643880224),
    AsymGalambosCopula(2, 10+5*0.3, 1.0, 1.0),
    AsymGalambosCopula(2, 10+5*0.7, 0.2, 0.9),
    AsymGalambosCopula(2, 11.647356700032505, 0.6195348270893413, 0.4197760589260566),
    AsymGalambosCopula(2, 5.0, 0.8, 0.3),
    AsymGalambosCopula(2, 5+4*0.4, 1.0, 1.0),
    AsymGalambosCopula(2, 5+4*0.1, 0.2, 0.6),
    AsymGalambosCopula(2, 8.810168494949659, 0.5987759444612732, 0.5391280234619427),
    AsymGalambosCopula(2, 0.9, 1.0, 1.0),
    AsymGalambosCopula(2, 0.3, 0.8, 0.1),
    AsymLogCopula(2, 1.0, 0.0, 0.0),
    AsymLogCopula(2, 1.0, 1.0, 1.0),
    AsymLogCopula(2, 1.0, 0.1, 0.6),
    AsymLogCopula(2, 1.2, 0.3,0.6),
    AsymLogCopula(2, 1.5, 0.5, 0.2),
    AsymLogCopula(2, 1+4*0.9, 0.0, 0.0),
    AsymLogCopula(2, 1+4*0.01, 1.0, 1.0),
    AsymLogCopula(2, 1+4*0.2, 0.3, 0.4),
    AsymLogCopula(2, 10+5*0.5, 0.0, 0.0),
    AsymLogCopula(2, 10+5*0.6, 1.0, 1.0),
    AsymLogCopula(2, 10+5*0.7, 0.8, 0.2),
    AsymMixedCopula(2, 0.1, 0.2),
    AsymMixedCopula(2, 0.12, 0.13),
    BB1Copula(2, 0.35, 1.0),
    BB1Copula(2, 1.2, 1.5),
    BB1Copula(2, 2.5, 1.5),
    BB2Copula(2, 1.2, 0.5),
    BB2Copula(2, 1.5, 1.8),
    BB2Copula(2, 2.0, 1.5),
    BB3Copula(2, 2.0, 1.5),
    BB3Copula(2, 2.5, 0.5),
    BB3Copula(2, 3.0, 1.0),
    BB4Copula(2, 0.50, 1.60),
    BB4Copula(2, 2.50, 0.40),
    BB4Copula(2, 3.0, 2.1),
    BB5Copula(2, 1.50, 1.60),
    BB5Copula(2, 2.50, 0.40),
    BB5Copula(2, 5.0, 0.5),
    BB6Copula(2, 1.2, 1.6),
    BB6Copula(2, 1.5, 1.4),
    BB6Copula(2, 2.0, 1.5),
    BB7Copula(2, 1.2, 1.6),
    BB7Copula(2, 1.5, 0.4),
    BB7Copula(2, 2.0, 1.5),
    BB8Copula(2, 1.2, 0.4),
    BB8Copula(2, 1.5, 0.6),
    BB8Copula(2, 2.5, 0.8),
    BB9Copula(2, 1.5, 2.4),
    BB9Copula(2, 2.0, 1.5),
    BB9Copula(2, 2.8, 2.6),
    BB10Copula(2, 1.5, 0.7),
    BB10Copula(2, 3.0, 0.8),
    BB10Copula(2, 4.5, 0.6),
    BC2Copula(2, 0.5, 0.3),
    BC2Copula(2, 0.5, 0.5),
    BC2Copula(2, 0.5516353577049822, 0.33689370624999193),
    BC2Copula(2, 0.7,0.3),
    BC2Copula(2, 1.0, 0.0),
    BC2Copula(2, 1/2,1/2),
    BC2Copula(2, 0.6, 0.8),
    BernsteinCopula(ArchimaxCopula(2, Copulas.FrankGenerator(0.8), Copulas.HuslerReissTail(0.6)); m=5),
    BernsteinCopula(ClaytonCopula(3, 3.3); m=5),
    BernsteinCopula(GalambosCopula(2, 2.5); m=5),
    BernsteinCopula(GaussianCopula(2, 0.3); m=5),
    BernsteinCopula(IndependentCopula(4); m=5),
    ClaytonCopula(2, -0.7),
    ClaytonCopula(2, 0.9),
    ClaytonCopula(2, 0.3),
    ClaytonCopula(2, 7),
    ClaytonCopula(3, 7.3),
    ClaytonCopula(3, -0.36),
    ClaytonCopula(4, 3.7),
    ClaytonCopula(4, -0.22),
    ClaytonCopula(4,7.),
    Copulas.SubsetCopula(RafteryCopula(3, 0.5), (2,1)),
    CuadrasAugeCopula(2, 0.0),
    CuadrasAugeCopula(2, 0.1),
    CuadrasAugeCopula(2, 0.3437537135972244),
    CuadrasAugeCopula(2, 0.7103550345192344),
    CuadrasAugeCopula(2, 0.8),
    CuadrasAugeCopula(2, 1.0),
    CuadrasAugeCopula(2, 0.2),
    FGMCopula(2, 0.0),
    FGMCopula(2, 0.4),
    FGMCopula(2,1),
    FGMCopula(3, [0.3,0.3,0.3,0.3]),
    FGMCopula(3,[0.1,0.2,0.3,0.4]),
    FrankCopula(2,-5),
    FrankCopula(2,0.5),
    FrankCopula(2,1-log(0.9)),
    FrankCopula(2,1.0),
    FrankCopula(3,1-log(0.1)),
    FrankCopula(3,1.0),
    FrankCopula(3,12),
    FrankCopula(4,1-log(0.3)),
    FrankCopula(4,1.0),
    FrankCopula(4,150),
    FrankCopula(4,30),
    FrankCopula(4,37),
    GalambosCopula(2, 0.3),
    GalambosCopula(2, 1+4*0.5),
    GalambosCopula(2, 120),
    GalambosCopula(2, 20),
    GalambosCopula(2, 210),
    GalambosCopula(2, 4.3),
    GalambosCopula(2, 8),
    GalambosCopula(2, 80),
    GalambosCopula(2, 0.7),
    GaussianCopula([1 0.5; 0.5 1]),
    GaussianCopula([1 0.7; 0.7 1]),
    GumbelBarnettCopula(2,1.0),
    GumbelBarnettCopula(2,0.7),
    GumbelBarnettCopula(3,0.1),
    GumbelBarnettCopula(3,0.35),
    GumbelBarnettCopula(3,0.2*0.38),
    GumbelBarnettCopula(4,0.2),
    GumbelCopula(2, 1.2),
    GumbelCopula(2,1-log(0.9)),
    GumbelCopula(2,8),
    GumbelCopula(3,1-log(0.2)),
    GumbelCopula(4,1-log(0.3)),
    GumbelCopula(4,100),
    GumbelCopula(4,20),
    GumbelCopula(4,7),
    HuslerReissCopula(2, 0.1),
    HuslerReissCopula(2, 0.256693308150987),
    HuslerReissCopula(2, 1.6287031392529938),
    HuslerReissCopula(2, 3.5),
    HuslerReissCopula(2, 5.319851350643586),
    IndependentCopula(2),
    IndependentCopula(3),
    InvGaussianCopula(2,-log(0.9)),
    InvGaussianCopula(2,1.0),
    InvGaussianCopula(2,0.2),
    InvGaussianCopula(3,-log(0.6)),
    InvGaussianCopula(3,0.4),
    InvGaussianCopula(4,-log(0.1)),
    InvGaussianCopula(4,0.05),
    InvGaussianCopula(4,1.0),
    JoeCopula(2,1-log(0.5)),
    JoeCopula(2,3),
    JoeCopula(2,Inf),
    JoeCopula(3,1-log(0.3)),
    JoeCopula(3,7),
    JoeCopula(4,1-log(0.1)),
    LogCopula(2, 1.5),
    LogCopula(2, 1+9*0.4),
    LogCopula(2, 5.5),
    MCopula(2),
    MCopula(4),
    MixedCopula(2, 0.0),
    MixedCopula(2, 0.2),
    MixedCopula(2, 0.5),
    MixedCopula(2, 1.0),
    MOCopula(2, 0.1,0.2,0.3),
    MOCopula(2, 0.5, 0.5, 0.5),
    MOCopula(2, 0.5960710257852946, 0.3313524247810329, 0.09653466861970061),
    MOCopula(2, 1.0, 1.0, 1.0),
    MOCopula(2, 0.1, 0.5, 0.9),
    PlackettCopula(0.5),
    PlackettCopula(0.8),
    PlackettCopula(2.0),
    RafteryCopula(2, 0.2),
    RafteryCopula(3, 0.5),
    SurvivalCopula(ClaytonCopula(2,-0.7),(1,2)),
    SurvivalCopula(RafteryCopula(2, 0.2), (2,1)),
    TCopula(2, [1 0.7; 0.7 1]),
    TCopula(20,[1 -0.5; -0.5 1]),
    TCopula(4, [1 0.5; 0.5 1]),
    tEVCopula(2, 10.0, 1.0),
    tEVCopula(2, 2.0, 0.5),
    tEVCopula(2, 3.0, 0.0),
    tEVCopula(2, 4.0, 0.5),
    tEVCopula(2, 4+6*0.5, -0.9+1.9*0.3),
    tEVCopula(2, 5.0, -0.5),
    tEVCopula(2, 5.466564460573727, -0.6566645244416698),
    WCopula(2),
    ]

# These few ones are forced to be random, but we control their rng like that to have reproducibility: 
Random.seed!(rng, 123)
append!(Bestiary, [
    ArchimedeanCopula(2, EmpiricalGenerator(randn(rng, 4, 150))),
    ArchimedeanCopula(3, EmpiricalGenerator(randn(rng, 3, 200))),
    BernsteinCopula(randn(rng, 2,100), pseudo_values=false),
    BetaCopula(randn(rng, 2,50)),
    BetaCopula(randn(rng, 3,50)),
    CheckerboardCopula(randn(rng, 2,50); pseudo_values=false),
    CheckerboardCopula(randn(rng, 3,50); pseudo_values=false),
    CheckerboardCopula(randn(rng, 4,50); pseudo_values=false),
    EmpiricalCopula(randn(2,50),pseudo_values=false),
    EmpiricalCopula(randn(2,50),pseudo_values=false),
    EmpiricalEVCopula(randn(rng, 2,50); method=:cfg, pseudo_values=false),
    EmpiricalEVCopula(randn(rng, 2,50); method=:ols, pseudo_values=false),
    EmpiricalEVCopula(randn(rng, 2,50); method=:pickands, pseudo_values=false),
])

macro testif(cond, args...)
    # --- Minimal, readable helper to conditionally run/skip whole testsets ---
    # Usage:
    #   @testif condition "Name" begin ... end
    #   @testif condition verbose=true "Name" begin ... end
    nargs = length(args)
    nargs >= 2 || error("Usage: @testif condition [options...] \"Name\" begin ... end")
    name  = args[end-1]
    block = args[end]
    opts  = nargs > 2 ? args[1:end-2] : ()
    return :(if $(esc(cond))
        Test.@testset $(opts...) $(name) begin
            $(esc(block))
        end
    else
        Test.@testset $(opts...) $(name) begin
            Test.@test_skip "skipped by @testif"
        end
    end)
end

can_pdf(C::Copulas.Copula) = applicable(Distributions._logpdf, C, ones(length(C),2)./2) 
can_pdf(C::EmpiricalCopula) = false
can_pdf(C::ArchimedeanCopula) = length(C) > Copulas.max_monotony(C.G)

check_rosenblatt(C::Copulas.Copula) = true
check_rosenblatt(C::ArchimedeanCopula) = length(C) > Copulas.max_monotony(C.G)
check_rosenblatt(C::FrankCopula) = C.G.Î¸ < 100
check_rosenblatt(C::GumbelCopula) = C.G.Î¸ < 20
check_rosenblatt(C::MCopula{4}) = false
check_rosenblatt(C::EmpiricalCopula) = false
check_rosenblatt(C::BC2Copula) = false

check_corkendall(C::Copulas.Copula) = true
check_corkendall(C::FrankCopula) = C.G.Î¸ < 100
check_corkendall(C::GumbelCopula) = C.G.Î¸ < 100
check_corkendall(C::MCopula) = false
check_corkendall(C::WCopula) = false
check_corkendall(C::EmpiricalCopula) = false
check_corkendall(C::BC2Copula) = false
check_corkendall(C::CuadrasAugeCopula) = false
check_corkendall(C::MOCopula) = false
check_corkendall(C::Copulas.ExtremeValueCopula{2, <:Copulas.EmpiricalEVTail}) = false

is_archimedean_with_generator(C::Copulas.Copula) = false
is_archimedean_with_generator(C::ArchimedeanCopula) = true 
is_archimedean_with_generator(C::ArchimedeanCopula{d, Copulas.WilliamsonGenerator{<:Distributions.DiscreteUnivariateDistribution, D}}) where {d,D} = false

can_integrate_pdf(C::Copulas.Copula) = can_pdf(C)
can_integrate_pdf(C::FrankCopula) = C.G.Î¸ < 100
can_integrate_pdf(C::FGMCopula) = length(C) != 3
can_integrate_pdf(C::MCopula) = false
can_integrate_pdf(C::WCopula) = false
can_integrate_pdf(C::MOCopula) = false
can_integrate_pdf(C::CuadrasAugeCopula) = false
can_integrate_pdf(C::RafteryCopula) = false
can_integrate_pdf(C::EmpiricalCopula) = false
can_integrate_pdf(C::BC2Copula) = false
can_integrate_pdf(C::Copulas.ExtremeValueCopula{2, <:Copulas.EmpiricalEVTail}) = false
can_integrate_pdf(C::CheckerboardCopula) = false

can_ad(C::Copulas.Copula) = can_pdf(C)
can_ad(C::FrankCopula) = C.G.Î¸ < 100
can_ad(C::MCopula) = false
can_ad(C::WCopula) = false
can_ad(C::tEVCopula) = false
can_ad(C::TCopula) = false
can_ad(C::CuadrasAugeCopula) = false
can_ad(C::MOCopula) = false

is_bivariate(C::Copulas.Copula) = (length(C) == 2)
has_subsetdims(C::Copulas.Copula) = !is_bivariate(C)

check_cdf_rand(C::Copulas.Copula) = true
check_cdf_rand(C::BC2Copula) = false
check_cdf_rand(C::MOCopula) = false
check_cdf_rand(C::CuadrasAugeCopula) = false

dep_coherency_enabled(C::Copulas.Copula) = true
dep_coherency_enabled(C::MOCopula) = false
dep_coherency_enabled(C::Copulas.ExtremeValueCopula{2, <:Copulas.EmpiricalEVTail}) = false

check_biv_conditioning(C::Copulas.Copula) = is_bivariate(C) && can_ad(C)
check_biv_conditioning(C::CheckerboardCopula) = false

check_highdim_conditioning(C::Copulas.Copula) = (length(C) âˆˆ (3,4)) && can_ad(C)
check_highdim_conditioning(C::CheckerboardCopula) = false

has_uniform_margins(C::Copulas.Copula) = true
has_uniform_margins(C::EmpiricalCopula) = false

is_archimedean(C::Copulas.Copula) = false
is_archimedean(C::ArchimedeanCopula) = true

is_extremevalue(C::Copulas.Copula) = false
is_extremevalue(C::Copulas.ExtremeValueCopula) = true

is_archimax(C::Copulas.Copula) = false
is_archimax(C::Copulas.ArchimaxCopula) = true

can_be_fitted(C::CT, d) where CT = length(Copulas._available_fitting_methods(CT, d)) > 0

has_parameters(C::Copulas.Copula) = true
has_parameters(C::Union{IndependentCopula, MCopula, WCopula}) = false

has_unbounded_params(C::CT, d) where CT = has_parameters(C) && 
    (:mle âˆˆ Copulas._available_fitting_methods(CT, d)) && 
    (length(Distributions.params(C)) > 0)
has_unbounded_params(C::EmpiricalEVCopula, d) = false
has_unbounded_params(C::FGMCopula, d) = d == 2

unbounding_is_a_bijection(C::Copulas.Copula) = true
unbounding_is_a_bijection(C::FGMCopula) = length(C)==2

function generator_specialization(gen::TG) where TG<:Copulas.Generator
    Ï•     = which(Copulas.Ï•,      (TG, Float64))      != which(Copulas.Ï•,      (Copulas.FrailtyGenerator, Float64))
    Ï•1    = which(Copulas.Ï•â½Â¹â¾,   (TG, Float64))      != which(Copulas.Ï•â½Â¹â¾,   (Copulas.Generator, Float64))
    Ï•k    = which(Copulas.Ï•â½áµâ¾,   (TG, Int, Float64)) != which(Copulas.Ï•â½áµâ¾,   (Copulas.Generator, Int, Float64))
    Ï•inv  = which(Copulas.Ï•â»Â¹,    (TG, Float64))      != which(Copulas.Ï•â»Â¹,    (Copulas.Generator, Float64))
    Ï•inv1 = which(Copulas.Ï•â»Â¹â½Â¹â¾, (TG, Float64))      != which(Copulas.Ï•â»Â¹â½Â¹â¾, (Copulas.Generator, Float64))
    Ï•kinv = which(Copulas.Ï•â½áµâ¾â»Â¹, (TG, Int, Float64)) != which(Copulas.Ï•â½áµâ¾â»Â¹, (Copulas.Generator, Int, Float64))
    Ï„inv = applicable(Copulas.Ï„, gen) && applicable(Copulas.Ï„â»Â¹, TG, 1.0)
    Ïinv = applicable(Copulas.Ï, gen) && applicable(Copulas.Ïâ»Â¹, TG, 1.0)
    return (; Ï•, Ï•1, Ï•k, Ï•inv, Ï•inv1, Ï•kinv, Ï„inv, Ïinv)
end

function tail_specialization(tail::TT) where TT<:Copulas.Tail
    dA =        which(Copulas.dA,        (TT, Float64))                 != which(Copulas.dA,        (Copulas.Tail2, Float64))
    dÂ²A =       which(Copulas.dÂ²A,       (TT, Float64))                 != which(Copulas.dÂ²A,       (Copulas.Tail2, Float64))
    _A_dA_dÂ²A = which(Copulas._A_dA_dÂ²A, (TT, Float64))                 != which(Copulas._A_dA_dÂ²A, (Copulas.Tail2, Float64))
    â„“ =         which(Copulas.â„“,         (TT, Tuple{Float64, Float64})) != which(Copulas.â„“,         (Copulas.Tail2, Tuple{Float64, Float64}))
    return (; dA, dÂ²A, _A_dA_dÂ²A, â„“)
end

# A few technical helpers. 

function _integrate_pdf_rect(rng, C::Copulas.Copula{d}, a, b, N) where d
    ba = b .- a
    logvol = log(prod(ba))
    logS  = -Inf
    logS2 = -Inf
    u = zeros(d)
    x = similar(a)
    @inbounds for _ in 1:N
        rand!(rng, u)
        x .=  a .+ ba .* u
        lp = logpdf(C, x)
        if isfinite(lp)
            log_fx = lp + logvol
            logS   = LogExpFunctions.logaddexp(logS,  log_fx)
            logS2  = LogExpFunctions.logaddexp(logS2, 2 * log_fx)
        end
    end
    Î¼  = exp(logS  - log(N))
    m2 = exp(logS2 - log(N))
    r  = max(m2 - Î¼^2, 0.0) / N
    return Î¼, r, :mc_pdf
end

# You can filter the bestiary here if you want: 
Bestiary = filter(GenericTestFilter, Bestiary)

# Launch the main computation: 
@testset for C in unique(Bestiary) 

    @info "Testing $C..."
    Random.seed!(rng,123)
    CT = typeof(C)
    d = length(C)
    
    Z = SklarDist(C, ntuple(_ -> Normal(), d))
    spl1 = rand(rng, C)
    spl10 = rand(rng, C, 10)
    spl1000 = rand(rng, C, 1000)

    @testset "Basics" begin 
        @testset "Shape and support" begin 
            @test length(spl1)==d
            @test size(spl10) == (d,10)
            @test all(0 .<= spl10 .<= 1)
            @test all(0 .<= spl1000 .<= 1)
        end

        @testset "CDF boundary and measure" begin 
            @test iszero(cdf(C,zeros(d)))
            @test isone(cdf(C,ones(d)))
            @test 0 <= cdf(C,rand(rng,d)) <= 1
            @test cdf(Z,zeros(d)) >= 0
            @test Copulas.measure(C, zeros(d),    ones(d)) â‰ˆ 1
            @test Copulas.measure(C, ones(d)*0.2, ones(d)*0.4) >= 0
            @test Copulas.measure(C, zeros(d), spl1) â‰ˆ cdf(C, spl1)
        end

        @testif has_subsetdims(C) "Subsetdims" begin
            sC = Copulas.subsetdims(C,(2,1))
            @test all(0 .<= cdf(sC, spl10[1:2,:]) .<= 1)
        end

        # Margins uniformity
        @testif has_uniform_margins(C) "Margins uniformity" begin
            for i in 1:d
                for val in [0,1,0.5,rand(rng,5)...]
                    u = ones(d)
                    u[i] = val
                    @test cdf(C,u) â‰ˆ val atol=1e-5
                end
                u = rand(rng,d)
                u[i] = 0
                @test iszero(cdf(C,u))

                # This pvalue test fails sometimes.. which is normal since its random, but its anoying.
                # @test pvalue(ApproximateOneSampleKSTest(spl1000[i,:], Uniform())) > 0.005
            end
        end

        @testif can_pdf(C) "PDF positivity" begin
            r10 = pdf(C, spl10)
            @test pdf(C, zeros(d) .+ 1e-5) >= 0
            @test pdf(C, ones(d)/2)      >= 0
            @test pdf(C, ones(d) .- 1e-5) >= 0
            @test (all(r10 .>= 0) && all(isfinite.(r10)))
        end 

        # Generic sampler vs CDF sanity: P(U â‰¤ u) from samples should match cdf(C, u)
        @testif check_cdf_rand(C) "Empirical lower-orthant vs CDF" begin
            N = size(spl1000, 2)
            u = 0.8 .+ 0.2 .* rand(rng, d)
            p_th = cdf(C, u)
            p_hat = mean(all(spl1000 .<= u, dims=1))
            se = sqrt(max(p_th * (1 - p_th) / N, 0.0))
            @test abs(p_hat - p_th) â‰¤ max(5*se, 2e-3)
        end


        # This test takes more than 5 hours to run 
        # This is clarly unacceptable, but moreover we dont know which copula takes the most time 
        # sadly ;)
        
        # @testif dep_coherency_enabled(C) "Dependence metrics coherency" begin
        #     # Empirical vs theoretical for available metrics, mirroring Kendallâ€™s pattern
        #     metrics = (
        #         ("tau", Copulas.Ï„, StatsBase.corkendall, 0.10, -1, 1), 
        #         ("rho", Copulas.Ï, StatsBase.corspearman, 0.10, -1 , 1), 
        #         ("beta", Copulas.Î², Copulas.corblomqvist, 0.10, -1 , 1), 
        #         ("gamma", Copulas.Î³, Copulas.corgini, 0.15, -1 , 1), 
        #         ("iota", Copulas.Î¹, Copulas.corentropy, 0.15, -Inf , 0)
        #     )
        #     for (name, f, corf, tol, lb, ub) in metrics
        #         @testset "$name" begin
        #             thf = f(C)
        #             thcorf = corf(C)
        #             empf = f(spl1000)
                    
        #             @test isapprox(empf, thf; atol=tol)
        #             @test lb â‰¤ thf â‰¤ ub
        #             @test lb â‰¤ empf â‰¤ ub
        #             @test all(lb .â‰¤ thcorf .â‰¤ ub)

        #             if which(f, (CT,)) !=  which(f, (Copulas.Copula{d},))
        #                 thf_gen  = @invoke f(C::Copulas.Copula{d})
        #                 # Allow tiny numerical discrepancies
        #                 @test isapprox(thf, thf_gen; atol= (C isa GaussianCopula ? 0.1 : 0.001))
        #             end
        #             if d == 2
        #                 @test isapprox(thf, thcorf[1,2]; atol=0.1)
        #             else
        #                 @test all(lb .<= thcorf .<= ub)
        #             end
        #             if check_rosenblatt(C)
        #                 U = rosenblatt(C, spl1000)
        #                 empfu = f(U)
        #                 empcorfu = corf(U')
        #                 @test isapprox(empfu, 0.0; atol=tol+0.05)
        #                 for i in 1:(d - 1)
        #                     for j in (i + 1):d
        #                         @test empcorfu[i,j] â‰ˆ 0.0 atol = 0.15
        #                     end
        #                 end
        #             end
        #         end
        #     end

        @testif dep_coherency_enabled(C) "Corkendall coeherency" begin
            K = corkendall(spl1000')
            Kth = corkendall(C)
            @test all(-1 .<= Kth .<= 1)
            @test all(isapprox.(Kth, K; atol=0.2))
        end
    end

    @testif can_integrate_pdf(C) "Testing pdf integration" begin
        # 1) âˆ«_{[0,1]^d} pdf = 1  (hcubature if dâ‰¤3; si no, MC)
        v, r, _ = _integrate_pdf_rect(rng, C, zeros(d), ones(d), 1_500)
        @test isapprox(v, 1; atol=max(5*sqrt(r), 1e-3))

        # 2) âˆ«_{[0,0.5]^d} pdf = C(0.5,â€¦,0.5)
        b = ones(d)/2
        v2, r2, _ = _integrate_pdf_rect(rng, C, zeros(d), b, 1_500)
        @test isapprox(v2, cdf(C, b); atol=max(10*sqrt(r2), 1e-3))

        # 3) random rectangle, compare with measure (cdf based)
        a = rand(rng, d)
        b = a .+ rand(rng, d) .* (1 .- a)
        v3, r3, _ = _integrate_pdf_rect(rng, C, a, b, 1_500)
        @test (isapprox(v3, Copulas.measure(C, a, b); atol=max(20*sqrt(r3), 1e-3)) || max(v3, Copulas.measure(C, a, b)) < eps(Float64)) # wide tolerence, should pass. 
    end

    @testif check_rosenblatt(C) "rosenblatt âˆ˜ inverse_rosenblatt = Id" begin
        @test spl10 â‰ˆ inverse_rosenblatt(C, rosenblatt(C, spl10)) atol=1e-2
    end

    @testif check_corkendall(C) "corkendall âˆ˜ rosenblatt = I" begin
        Ï„mat = corkendall(rosenblatt(C, spl1000)')
        for i in 1:(d - 1)
            for j in (i + 1):d
                @test Ï„mat[i,j] â‰ˆ 0.0 atol = 0.15
            end
        end
    end

    @testset "Conditionning" begin
        # Conditioning tests (p = 1), validate against AD ratio and compare fast-paths to fallback
        # Always run basic sanity checks for bivariate conditionals; AD checks are gated below
        @testif is_bivariate(C) "(2 | 1): Basics & Specialization" begin
            us = (0.2, 0.5, 0.8)
            m_fast = which(Copulas.DistortionFromCop, (CT,                NTuple{1,Int}, NTuple{1,Float64}, Int))
            m_gen  = which(Copulas.DistortionFromCop, (Copulas.Copula{2}, NTuple{1,Int}, NTuple{1,Float64}, Int))
            has_spec = m_fast != m_gen
            for j in 1:2
                i = 3-j
                for v in (0.3, 0.7)
                    Dd = Copulas.condition(C, j, v)
                    vals = cdf.(Ref(Dd), us)
                    @test all(0.0 .<= vals .<= 1.0)
                    @test all(diff(collect(vals)) .>= -1e-10)
                    if check_biv_conditioning(C) && has_spec
                        Dgen  = @invoke Copulas.DistortionFromCop(C::Copulas.Copula{d}, (j,), (v,), i)
                        vals_gen  = cdf.(Ref(Dgen),  us)
                        for (vf, vg) in zip(vals, vals_gen)
                            @test isapprox(vf, vg, atol=1e-3, rtol=1e-3)
                        end
                    elseif CT <: Copulas.MCopula
                        @test all(vals .â‰ˆ min.(collect(us) ./ v, 1))
                    elseif CT <: Copulas.WCopula
                        @test all(vals .â‰ˆ max.(collect(us) .+ v .- 1, 0) ./ v)
                    end
                end
            end
        end
        @testif check_highdim_conditioning(C) "(d|d-2): Check conditional copula vs AD" begin
            js = tuple(collect(3:d)...)
            ujs = tuple(collect(0.25 + 0.5*rand(rng) for _ in js)...)  # interior values
            CC = condition(C, js, ujs)
            pts = [[0.2,0.3], [0.5,0.5], [0.8,0.6]]
            vals = cdf.(CC.C, pts) # only the conditional copula. 
            m_fast = which(Copulas.ConditionalCopula, (CT,                NTuple{d-2, Int}, NTuple{d-2, Float64}))
            m_gen  = which(Copulas.ConditionalCopula, (Copulas.Copula{d}, NTuple{d-2, Int}, NTuple{d-2, Float64}))
            if m_fast != m_gen
                CC_gen = @invoke Copulas.ConditionalCopula(C::Copulas.Copula{d}, js, ujs)
                for (v, p) in zip(vals,pts)
                    @test v â‰ˆ cdf(CC_gen, p) atol=1e-8 rtol=1e-8
                end
            end
        end
    end
    
    @testif is_archimedean_with_generator(C) "ArchimedeanCopula specific tests" begin 

        GT = typeof(C.G)
        spe = generator_specialization(C.G)
        mm = Copulas.max_monotony(C.G)
        
        @testif spe.Ï•inv "Check Ï• âˆ˜ Ï•â»Â¹ == Id over [0,1]" begin
            for x in 0:0.1:1
                @test Copulas.Ï•(C.G,Copulas.Ï•â»Â¹(C.G,x)) â‰ˆ x atol=1e-10
            end
        end

        @testif spe.Ï•1 "Check d(Ï•) == Ï•â½Â¹â¾" begin 
            @test ForwardDiff.derivative(x -> Copulas.Ï•(C.G, x), 0.1) â‰ˆ Copulas.Ï•â½Â¹â¾(C.G, 0.1)
        end

        @testif spe.Ï•k "Check d(Ï•) == Ï•â½áµâ¾(k=1)" begin
            @test ForwardDiff.derivative(x -> Copulas.Ï•(C.G, x), 0.1) â‰ˆ Copulas.Ï•â½áµâ¾(C.G, 1, 0.1)
        end

        @testif (spe.Ï•1 || spe.Ï•k) "Check Ï•â½Â¹â¾ == Ï•â½áµâ¾(k=1)" begin
            @test Copulas.Ï•â½Â¹â¾(C.G, 0.1) â‰ˆ Copulas.Ï•â½áµâ¾(C.G, 1, 0.1)
        end
        @testif (spe.Ï•1 || spe.Ï•k) "Check d(Ï•â½Â¹â¾) == Ï•â½áµâ¾(k=2)" begin
            @test ForwardDiff.derivative(x -> Copulas.Ï•â½Â¹â¾(C.G, x), 0.1) â‰ˆ Copulas.Ï•â½áµâ¾(C.G, 2, 0.1)
        end

        @testif spe.Ï•inv1 "Check d(Ï•â»Â¹) == Ï•â»Â¹â½Â¹â¾" begin
            @test ForwardDiff.derivative(x -> Copulas.Ï•â»Â¹(C.G, x), 0.5) â‰ˆ Copulas.Ï•â»Â¹â½Â¹â¾(C.G, 0.5)
        end

        @testif spe.Ï•kinv "Check Ï•â½áµâ¾â»Â¹ âˆ˜ Ï•â½áµâ¾ == Id for k in 1:d-2" begin
            for k in 1:d-2
                @test Copulas.Ï•â½áµâ¾â»Â¹(C.G,k, Copulas.Ï•â½áµâ¾(C.G, k, 0.1)) â‰ˆ 0.1
            end
        end

        # For generators that are only d-monotonous, this does not need to be true. 
        @testif (spe.Ï•kinv && (mm > d)) "Check Ï•â½áµâ¾â»Â¹ âˆ˜ Ï•â½áµâ¾ == Id for k=d-1" begin 
            @test Copulas.Ï•â½áµâ¾â»Â¹(C.G,d-1, Copulas.Ï•â½áµâ¾(C.G, d-1, 0.1)) â‰ˆ 0.1
        end

        @testif spe.Ï„inv "Check Ï„ âˆ˜ Ï„â»Â¹ == Id" begin
            tau = Copulas.Ï„(C)
            @test Copulas.Ï„(GT(Copulas.Ï„â»Â¹(CT,tau))) â‰ˆ tau
        end
        
        @testif spe.Ïinv "Check Ï âˆ˜ Ïâ»Â¹ == Id" begin
            rho = Copulas.Ï(C)
            @test -1 <= rho <= 1
            @test Copulas.Ï(GT(Copulas.Ïâ»Â¹(CT,rho))) â‰ˆ rho
        end

        if C.G isa Copulas.FrailtyGenerator
            F = frailty(C.G)
            @testif (spe.Ï• && applicable(mgf, F, -1.0)) "Check frailty matches Ï•" begin
                for t in 0:0.1:2
                    @test Ï•(C.G, t) == mgf(F, -t)
                end
            end
        end

        @testif !(C.G isa WilliamsonGenerator{<:Dirac, D} where D) "Kendall-Radial coherency test" begin
            # On radial-level: reuse the same radial sample for both checks
            R1 = dropdims(sum(Copulas.Ï•â»Â¹.(C.G,spl1000),dims=1),dims=1)
            R2 = rand(rng,Copulas.ğ’²â‚‹â‚(C.G, d),1000)
            @test pvalue(ApproximateTwoSampleKSTest(R1,R2)) > 0.005

            # On kendall-level: map Ï• over the same radial sample
            U1 = Distributions.cdf(C, spl1000)
            U2 = Copulas.Ï•.(Ref(C.G), R2)
            @test pvalue(ApproximateTwoSampleKSTest(U1, U2)) > 0.005
        end
    end

    # Extreme value copula-specific tests (bivariate)
    @testif (is_extremevalue(C) && is_bivariate(C)) "ExtremeValueCopula specific tests" begin
        spe = tail_specialization(C.tail)

        @testset "A function basics" begin
            @test Copulas.A(C.tail, 0.0) â‰ˆ 1
            @test Copulas.A(C.tail, 1.0) â‰ˆ 1
            t = rand(rng)
            A_value = Copulas.A(C.tail, t)
            @test 0.0 <= A_value <= 1.0
            @test isapprox(A_value, max(t, 1-t); atol=1e-6) || A_value >= max(t, 1-t)
            @test A_value <= 1.0
        end

        @testif (spe.dA || spe.dÂ²A || spe._A_dA_dÂ²A) "Testing derivatives of A" begin
            # FD-based checks only when available
            @testif !(CT<:tEVCopula) "FD derivatives availability" begin
                for t in (0.05, 0.5, 0.95)
                    @test isapprox(Copulas.dA(C.tail, t), ForwardDiff.derivative(x -> Copulas.A(C.tail, x), t); atol=1e-6)
                    @test isapprox(Copulas.dÂ²A(C.tail, t), ForwardDiff.derivative(x -> Copulas.dA(C.tail, x), t); atol=1e-6)
                end
            end
            # Triplet consistency always
            for t in (0.05, 0.5, 0.95)
                a, da, d2a = Copulas._A_dA_dÂ²A(C.tail, t)
                @test isapprox(a, Copulas.A(C.tail, t); atol=1e-8)
                @test isapprox(da, Copulas.dA(C.tail, t); atol=1e-8)
                @test isapprox(d2a, Copulas.dÂ²A(C.tail, t); atol=1e-8)
            end
        end

        @testif (spe.dA || spe.dÂ²A || spe._A_dA_dÂ²A || spe.â„“) "Testing â„“ and cdf for Extreme Value Copula" begin 
            u, v = rand(rng), rand(rng)
            x, y = -log(u), -log(v)
            s = y / (x + y)
            expected_â„“ = Copulas.A(C.tail, s) * (x + y)
            @test isapprox(Copulas.â„“(C.tail, (x, y)), expected_â„“; atol=0.1)
            expected_cdf = exp(-expected_â„“)
            @test isapprox(cdf(C, [u, v]), expected_cdf; atol=0.1)

            @testif !(CT<:tEVCopula) "pdf via FD matches analytic" begin
                u, v = rand(rng), rand(rng)
                num_pdf = ForwardDiff.derivative(u_ -> ForwardDiff.derivative(v_ -> cdf(C, [u_, v_]), v), u)
                ana_pdf = pdf(C, [u, v])
                @test isapprox(ana_pdf, num_pdf; atol=0.1)
            end
        end
    end

    # Archimax specific tests
    @testif is_archimax(C) "ArchimaxCopula specific tests" begin

            for (u1,u2) in ((0.2,0.3), (0.7,0.6), (0.9,0.4))

                # truth: 
                c  = cdf(C, [u1,u2])
                lp = logpdf(C, [u1, u2])
                p  = pdf(C, [u1,u2])

                # mockups: 
                c_mock = begin 
                    (u1â‰¤0 || u2â‰¤0)  && return 0.0
                    (u1â‰¥1 && u2â‰¥1)  && return 1.0
                    x = Copulas.Ï•â»Â¹(C.gen, u1)
                    y = Copulas.Ï•â»Â¹(C.gen, u2)
                    S = x + y
                    S == 0 && return 1.0
                    t = y / S
                    Copulas.Ï•(C.gen, S * Copulas.A(C.tail, t))
                end
                p_mock = max(ForwardDiff.hessian(Base.Fix1(cdf, C), [u1, u2])[1,2], 0.0)

                @test isapprox(c, c_mock; rtol=1e-12, atol=1e-12)
                @test isfinite(lp)
                @test exp(lp) â‰ˆ p
                @test isapprox(p, p_mock; rtol=1e-6, atol=1e-8)

            end

    end

    @testif can_be_fitted(C, d) "Fitting interface"  begin
        @testif has_unbounded_params(C, d) "Unbouding and rebounding params" begin
            # First on the _example copula. 
            Î¸â‚€ = Distributions.params(Copulas._example(CT, d))
            Î¸â‚ = Copulas._rebound_params(CT, d, Copulas._unbound_params(CT, d, Î¸â‚€))
            @testif unbounding_is_a_bijection(C) "bijective unbounding" begin 
                @test all(k->getfield(Î¸â‚€,k) â‰ˆ getfield(Î¸â‚,k), keys(Î¸â‚€))
            end
            @test Copulas._unbound_params(CT, d, Distributions.params(CT(d, Î¸â‚€...))) == Copulas._unbound_params(CT, d, Î¸â‚€)

            # Then on the copula we have at hand:
            Î¸â‚€ = Distributions.params(C)
            Î¸â‚ = Copulas._rebound_params(CT, d, Copulas._unbound_params(CT, d, Î¸â‚€))
            @testif unbounding_is_a_bijection(C) "bijective unbounding" begin 
                @test all(k->getfield(Î¸â‚€,k) â‰ˆ getfield(Î¸â‚,k), keys(Î¸â‚€))
            end
            @test Copulas._unbound_params(CT, d, Distributions.params(CT(d, Î¸â‚€...))) == Copulas._unbound_params(CT, d, Î¸â‚€)
        end

        methods = Copulas._available_fitting_methods(CT, d)
        for m in methods
            if (CT<:GumbelCopula && C.G.Î¸ > 19 && m==:irho) || (CT<:FrankCopula && C.G.Î¸ > 99 && m==:mle) || (CT<:RafteryCopula && d==3 && m==:itau)
                continue
            end 
            @testset "Fitting CT for $(m)" begin
                r1 = fit(CT, spl10, m)
                newCT = typeof(r1)
            end
        end
    end
end